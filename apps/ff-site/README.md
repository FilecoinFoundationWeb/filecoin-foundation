# Filecoin Foundation Website

## Overview

This project contains the website of Filecoin Foundation, available at [fil.org](https://fil.org/). It aims to provide comprehensive information and resources about Filecoin's initiatives and contributions to the decentralized web.

## Getting Started

This [Next.js project](https://nextjs.org/docs) is part of a monorepo managed by [Turborepo](https://turborepo.com/docs). To get started, refer to the [root README](../../README.md) for installation and development instructions.

If you're only interested in working on the website, you can run `npm run dev` in this directory, assuming you have already installed the dependencies at the root of the monorepo.

## Technologies

- **Next.js 15**: For server-side rendering, static site generation, and routing.
- **TypeScript**: For static type checking.
- **Tailwind CSS**: For utility-first CSS styling.
- **Zod**: For data validation.

## Decap CMS Integration

We use [Decap CMS](https://decapcms.org/docs/intro/), formerly known as Netlify CMS, for content management, allowing non-technical team members to update website content easily.

Decap CMS is a Git-based content management system, meaning that content is managed just like any other file in our repository, using Git for version control.

All the content managed through Decap CMS is stored in `src/app/content/`. This directory includes various Markdown files that the CMS edits. Each file represents a different section or page of the website, structured for easy editing and updates.

### Decap CMS Configuration

The Decap CMS setup includes two configuration files:

1. `public/admin/config.yml` - This file primarily contains the schema and metadata for the content but also includes authentication settings among other things.
2. `public/admin/index.html` - This HTML template enables viewing and editing the content in a web interface. Access it via [/admin/index.html](http://localhost:3000/admin/index.html#/).

Additionally, `src/app/_data/cmsConfigSchema.json` is a file autogenerated when the server starts, using `predev` and `prebuild` commands.

### Markdown Files

We use [Markdown](https://www.markdownguide.org/cheat-sheet/) files for the content of our websites. It allows us to convert human-readable text into HTML.

Each Markdown file typically consists of two parts:

1. The header section: Delimited with triple dashes `---`, this YAML-formatted section contains metadata about the file, similar to what you would find in HTML `<head>` tags: title, description, image links, etc.
2. The body section: Contains the content itself in Markdown format.

Here’s an example:

```markdown
---
title: Hello
slug: home
---

# Hello world!

Lorem ipsum
```

Metadata is processed using the [gray-matter](https://www.npmjs.com/package/gray-matter) library, transforming it into an object usable within our code to display content in relevant places:

```javascript
{
  data: { title: 'Hello', slug: 'home' },
  content: '<h1>Hello world!</h1><p>Lorem ipsum</p>',
}
```

### How to Update Content

#### Updating Existing Content

If you only need to update existing content, there is no need to update Decap’s configuration. Modify the markdown file for the content you wish to update. For example, to change the title on the home page:

1. Open `src/content/pages/home.md`.
2. Edit the title in the header section.

The website should hot reload and the changes should appear immediately in your local development environment. Once you’re satisfied with the updates, commit your changes via Git.

#### Adding or Removing Content

If you need to add or remove content from a page or a section, like a subtitle on the home page, then Decap CMS must be informed. Hence, you need to update both the Markdown and the configuration file.

1. Add the new content in the Markdown file, e.g., a subtitle in the header of `src/content/pages/home.md`.
2. Update `public/admin/config.yml` to reflect this addition under the appropriate section, for example:

```yaml
# collections -> name: "pages” -> name: "home”

fields:
  - *header_config
  - name: "subtitle"
    label: "Subtitle"
    widget: "string"
    required: true
```

The `widget` key is important and worth mentioning. Widgets define the content type of each field: `String`, `Number`, `Boolean`, `DateTime`, `File`, `Relation`, etc. The full list of widgets and their purpose can be found in the [Decap CMS documentation](https://decapcms.org/docs/widgets/).

The `Relation` widget is how we create links between related pieces of content, such as associating a featured post with a blog page. Relations usually rely on slugs, which are unique identifiers, to link content together.

### Accessing the CMS

The CMS is accessible at `/admin`, whether [locally](http://localhost:3000/admin) or in [production](https://fil.org/admin).

#### Authenticating with GitHub in production

Our project integrates with Github for user authentication and content management in a production environment. This integration allows authorized users to access the CMS and make changes to the website content. The list of authorized users is available in the [settings of the GitHub repository](https://github.com/FilecoinFoundationWeb/filecoin-foundation/settings/access). We also use a [Cloudflare worker](https://github.com/FilecoinFoundationWeb/decap-proxy) to handle the authentication process.

This setup is only necessary for production. For local development, follow the instructions below.

#### Working with the CMS locally

You can connect Decap CMS to the local Git repository using Decap's local server by running `npx decap-server`. This will bypass the github authentication and allow you to work with the CMS locally.

### Data Encryption

Some personal information that we collect is encrypted due to the open source nature of the project. This includes the name and email of ecosystem project owners. We use the `CryptoJS.AES` library for encryption. The master key to encrypt and decrypt data is stored in the `.env` file under `ENCRYPTION_SECRET_KEY`.

```md
---
title: Ecosystem Project
email: encrypted::X4asd...
full-name: encrypted::X4zxc...
---
```

The CMS is able to encrypt and decrypt data thanks to a custom API endpoint located at `apps/ff-site/src/app/api/encryption/route.ts`. This endpoint is protected by a production-only environment variable called `ENCRYPTION_ENDPOINT_ACCESS_KEY`. This variable gets injected into the CMS by the `apps/ff-site/scripts/injectEncryptionAccessKeyInCMS.js` script at build time only on Vercel.

#### Decrypting information locally

When running the CMS locally, the API key is not injected as `injectEncryptionAccessKeyInCMS.js` only runs during Vercel builds. Hence, this error message is displayed `Could not perform decrypt operation for value: X4asd...` for encrypted values.

If you need to view these values in plain text, you can access the CMS in production to see the decrypted information. But if you absolutely need to decrypt values locally, you can call the `decrypt` function from `apps/ff-site/src/app/_utils/encryption.ts` and log the result to the console.

```ts
// apps/ff-site/src/app/(homepage)/page.tsx
import { decrypt } from "@/app/_utils/encryption"

console.log(decrypt("encrypted::X4asd..."))
```

Alternatively, you can also manually grab the API key from the [Vercel dashboard](https://vercel.com/filecoin-foundations-projects/filecoin-foundation-site/settings/environment-variables) and manually paste it where the `%ENCRYPTION_ENDPOINT_ACCESS_KEY%` placeholder is in `cmsEncryptionWidget.js`. Just remember to undo the changes before committing.

## Creating Page Templates

<!-- Should we keep it? -->

To create a new page template, run the following command:

`npm run generate:page <page-name>`

Replace `<page-name>` with the desired name of the page. This command will generate the following files with boilerplate content:

- `app/page-name/page.tsx`
- `app/page-name/layout.tsx`
- `app/page-name/utils/generateStructuredData.tsx`
- `cypress/e2e/page_name_spec.cy.ts`

It will also update `paths.ts` to include the new page.

## Lintind and Formatting

We rely on [ESLint](https://eslint.org/) and [Prettier](https://prettier.io/) to ensure code quality and consistency. We encourage contributors to set up their editors to run Prettier on save. For VSCode, you can add the following to your `.vscode/settings.json`:

```json
"editor.formatOnSave": true`.
```

ESLint is configured to run on pre-commit via [husky](https://typicode.github.io/husky/#/). To run it manually, use `npm run lint`. This is fix automatically fixable issues.

## Continuous Integration and Deployment

We use GitHub Actions for Continuous Integration (CI) to automate testing. Every pull request to the `main` branch must pass all tests and meet our quality standards. Below are the key workflows in our CI process:

- We run end-to-end (E2E) tests with [Cypress](https://www.cypress.io/) to ensure pages contain the correct content and metadata.
- We use [Percy](https://percy.io/) to compare visual changes between the PR and the production site. It's possible to disable it by adding `[skip percy]` to the PR title.
- We use [markdownlint-cli2](https://github.com/DavidAnson/markdownlint-cli2) to lint our Markdown files. This is especially helpful for PRs coming from Decap CMS, as the author doesn't have control over the formatting.

## End-to-End Testing with Cypress

To ensure the highest quality of user experience, we employ Cypress for end-to-end (E2E) testing.

### Running Tests Locally

To run Cypress tests on your local machine:

1. Ensure the development server is running: `npm run dev`
2. Open Cypress Test Runner with `npx cypress open` for interactive testing.
3. Alternatively, run `npx cypress run` to execute tests in headless mode directly from the terminal.

### Writing and Modifying Tests

Cypress tests are located in the `cypress/integration` directory.

This hands-on approach to testing complements our CI/CD pipeline, allowing developers to verify changes locally before committing them. For more information on Cypress and E2E testing strategies, visit [Cypress Documentation](https://docs.cypress.io).

## Development Guidelines

To maintain the quality and consistency of our codebase, we have established a set of development guidelines. Contributors are encouraged to follow these practices when making contributions to the project.

### Component Organization

Reusable React components should be stored in the general `_components` directory. Page-specific components should live closer to the page they are used on.

### Component Exports

Use named exports for React components to maintain consistency and support efficient tree shaking. This practice facilitates easier and more predictable imports across the project.

### Naming Props

When defining props for components, explicitly name the props type rather than using a generic `Props` type. For example,

```typescript
type BadgeProps = {
  featured: boolean
  children?: string
}
```

### Paths and URLs

- **Centralized Paths**: Utilize the `PATHS` object for defining and accessing paths throughout the application. See `_constants/paths.ts`

- **Site Metadata and URLs**: Reference site metadata and URLs using centralized constants to ensure consistency and ease of maintenance. See `_constants/siteMetadata.ts`

### Adding New Pages

When adding a new page to the project, please ensure the following:

1. **Update PATHS Configuration**: Ensure the `PATHS` object includes configurations for new content types, specifying paths, labels, and content directory paths. See `_constants/paths.ts`

2. **Metadata and SEO**: Each new page should have associated metadata and SEO tags defined. Use the `createMetadata` function to set up a page's metadata correctly. Example:

   ```javascript
   export const metadata = createMetadata(seo, PATHS.ABOUT.path)
   ```

3. **Structured Data**: Include structured data for the new page to enhance search engine visibility and accessibility. Use the `generateWebPageStructuredData` function to create structured data for the page, which provides the base structured data. Example:

   ```javascript
   const aboutPageBaseData = generateWebPageStructuredData({
     title: seo.title,
     description: seo.description,
     path: PATHS.ABOUT.path,
   })
   ```

   This can be further customized based on the page's content and structure. Example:

   ```javascript
   const aboutPageStructuredData: WithContext<WebPage> = {
     ...aboutPageBaseData,
     about: {
       '@type': 'Organization',
       name: ORGANIZATION_NAME,
       contactPoint: [
         {
           '@type': 'ContactPoint',
           contactType: FILECOIN_FOUNDATION_URLS.email.label,
           email: FILECOIN_FOUNDATION_URLS.email.href,
         },
         {
           '@type': 'ContactPoint',
           contactType:  FILECOIN_FOUNDATION_URLS.grants.email.label,
           email: FILECOIN_FOUNDATION_URLS.grants.email.href,
         },
       ],
     },
     sameAs: Object.values(FILECOIN_FOUNDATION_URLS.social).map(
       (link) => link.href
     ),
   }
   ```

4. **Testing**: Ensure that tests are added to verify the presence of metadata and structured data on the new page. These tests are crucial for maintaining the integrity of the site's SEO and ensuring that all pages meet our standards for content visibility.

5. **Updating the Sitemap**: When adding new dynamic content (such as blog posts, ecosystem projects, or events) that isn't automatically included in the sitemap through static routing, it's essential to manually update the sitemap with the new page's details. This step is crucial for SEO, helping ensure that search engines can easily discover and index these new pages.

Following these guidelines helps ensure that our website remains consistent, accessible, and search engine friendly.

## Contributing

We welcome contributions to Filecoin Foundation website!

### Github Workflow

We try to keep each pull request small and focused. If the work requires large file changes, we break it down into smaller pieces as outlined in this article on [GitHub Protips from Sarah Vessels](https://github.blog/developer-skills/github/github-protips-tips-tricks-hacks-and-secrets-from-sarah-vessels/)

## License

This project is licensed under the [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by/4.0/).
